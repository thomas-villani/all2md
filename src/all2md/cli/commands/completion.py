"""Shell completion script generators for all2md.

This module provides generators for bash, zsh, and PowerShell completion scripts.
Each generator produces a self-contained script with embedded option lists and
context-aware completion logic.
"""

from __future__ import annotations

import argparse
import sys
from typing import Any

from all2md.cli.help_formatter import _serialize_catalog_for_completion, build_help_renderer


def handle_completion_command(args: list[str] | None = None) -> int | None:
    """Handle the completion subcommand.

    Parameters
    ----------
    args : list[str] | None
        Command line arguments, defaults to sys.argv[1:]

    Returns
    -------
    int | None
        Exit code (0 for success) or None if not a completion command

    """
    if not args:
        args = sys.argv[1:]

    if not args or args[0] != "completion":
        return None

    completion_args = args[1:]

    parser = argparse.ArgumentParser(
        prog="all2md completion",
        description="Generate shell completion scripts for all2md",
    )
    parser.add_argument(
        "shell",
        choices=["bash", "zsh", "powershell"],
        help="Shell type for completion script",
    )

    try:
        parsed = parser.parse_args(completion_args)
    except SystemExit:
        return 1

    # Build catalog and serialize for completion
    renderer = build_help_renderer()
    catalog_data = _serialize_catalog_for_completion(renderer.catalog)

    # Generate appropriate completion script
    if parsed.shell == "bash":
        script = generate_bash_completion(catalog_data)
    elif parsed.shell == "zsh":
        script = generate_zsh_completion(catalog_data)
    elif parsed.shell == "powershell":
        script = generate_powershell_completion(catalog_data)
    else:
        print(f"Unsupported shell: {parsed.shell}", file=sys.stderr)
        return 1

    print(script)
    return 0


def generate_bash_completion(catalog: dict[str, Any]) -> str:
    """Generate bash completion script with embedded option data.

    Parameters
    ----------
    catalog : dict[str, Any]
        Serialized catalog data from _serialize_catalog_for_completion

    Returns
    -------
    str
        Complete bash completion script

    """
    # Extract data from catalog
    global_flags = [flag for opt in catalog["global"] for flag in opt["flags"]]
    formats = catalog["formats"]

    # Build format-specific option lists
    parser_flags_by_format: dict[str, list[str]] = {}
    for fmt, options in catalog["parsers"].items():
        parser_flags_by_format[fmt] = [flag for opt in options for flag in opt["flags"]]

    renderer_flags_by_format: dict[str, list[str]] = {}
    for fmt, options in catalog["renderers"].items():
        renderer_flags_by_format[fmt] = [flag for opt in options for flag in opt["flags"]]

    # Build choices mapping for options that have them
    choices_map: dict[str, list[str]] = {}
    for opt in catalog["global"]:
        if opt.get("choices"):
            for flag in opt["flags"]:
                choices_map[flag] = opt["choices"]

    # Generate bash script
    script = f"""# Bash completion for all2md
# Generated by: all2md completion bash
#
# Installation:
#   Save this file to: ~/.local/share/bash-completion/completions/all2md
#   Or source it from your .bashrc: source <(all2md completion bash)

_all2md_completion() {{
    local cur prev words cword
    _init_completion || return

    # Extract format from command line if present
    local format=""
    local output_type=""
    local i
    for ((i=1; i < ${{#words[@]}}; i++)); do
        case "${{words[i]}}" in
            --format=*)
                format="${{words[i]#--format=}}"
                ;;
            --format)
                if [[ $((i+1)) -lt ${{#words[@]}} ]]; then
                    format="${{words[i+1]}}"
                fi
                ;;
            -f)
                if [[ $((i+1)) -lt ${{#words[@]}} ]]; then
                    format="${{words[i+1]}}"
                fi
                ;;
            --output-type=*)
                output_type="${{words[i]#--output-type=}}"
                ;;
            --output-type)
                if [[ $((i+1)) -lt ${{#words[@]}} ]]; then
                    output_type="${{words[i+1]}}"
                fi
                ;;
        esac
    done

    # Detect format from input file extension if not explicitly specified
    if [[ -z "$format" ]]; then
        for ((i=1; i < ${{#words[@]}}; i++)); do
            local word="${{words[i]}}"
            if [[ "$word" =~ \\.(pdf|docx|html|md|txt|xlsx|pptx|csv|json|yaml|xml|rst|tex)$ ]]; then
                format="${{word##*.}}"
                break
            fi
        done
    fi

    # Handle option-specific completions
    case "$prev" in
        --format|-f)
            COMPREPLY=($(compgen -W "{' '.join(formats)}" -- "$cur"))
            return 0
            ;;
        --output-type)
            COMPREPLY=($(compgen -W "{' '.join(formats)}" -- "$cur"))
            return 0
            ;;
"""

    # Add choices completions for other options
    for flag, choices in choices_map.items():
        if flag not in ["--format", "-f", "--output-type"]:
            script += f"""        {flag})
            COMPREPLY=($(compgen -W "{' '.join(choices)}" -- "$cur"))
            return 0
            ;;
"""

    script += """    esac

    # Build list of available options based on context
    local opts="{} "

""".format(
        " ".join(global_flags)
    )

    # Add format-specific options
    for fmt in sorted(parser_flags_by_format.keys()):
        flags = " ".join(parser_flags_by_format[fmt])
        script += f"""    if [[ "$format" == "{fmt}" ]]; then
        opts="$opts {flags} "
    fi
"""

    # Add renderer-specific options
    for fmt in sorted(renderer_flags_by_format.keys()):
        flags = " ".join(renderer_flags_by_format[fmt])
        script += f"""    if [[ "$output_type" == "{fmt}" ]]; then
        opts="$opts {flags} "
    fi
"""

    script += """
    # Complete options only when user has typed -- or -
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts" -- "$cur"))
        return 0
    fi

    # Default to file completion
    _filedir
    return 0
}

complete -F _all2md_completion all2md
"""

    return script


def generate_zsh_completion(catalog: dict[str, Any]) -> str:
    """Generate zsh completion script with embedded option data.

    Parameters
    ----------
    catalog : dict[str, Any]
        Serialized catalog data from _serialize_catalog_for_completion

    Returns
    -------
    str
        Complete zsh completion script

    """
    # Build option specifications for _arguments
    option_specs: list[str] = []

    # Add global options
    for opt in catalog["global"]:
        flags = opt["flags"]
        help_text = opt.get("help", "").replace("'", "\\'").replace("[", "\\[").replace("]", "\\]")
        metavar = opt.get("metavar", "")

        if opt["is_flag"]:
            # Boolean flag
            if len(flags) == 1:
                option_specs.append(f"    '{flags[0]}[{help_text}]'")
            else:
                # Multiple flag variants (e.g., -o and --out)
                flag_group = "{" + ",".join(flags) + "}"
                option_specs.append(f"    '{flag_group}[{help_text}]'")
        else:
            # Option with value
            if opt.get("choices"):
                choices = " ".join(opt["choices"])
                if len(flags) == 1:
                    option_specs.append(f"    '{flags[0]}[{help_text}]:value:({choices})'")
                else:
                    flag_group = "{" + ",".join(flags) + "}"
                    option_specs.append(f"    '{flag_group}[{help_text}]:value:({choices})'")
            else:
                if len(flags) == 1:
                    option_specs.append(f"    '{flags[0]}[{help_text}]:{metavar}:_files'")
                else:
                    flag_group = "{" + ",".join(flags) + "}"
                    option_specs.append(f"    '{flag_group}[{help_text}]:{metavar}:_files'")

    # Generate zsh script
    script = f"""#compdef all2md
# Zsh completion for all2md
# Generated by: all2md completion zsh
#
# Installation:
#   Save this file to a directory in your $fpath as _all2md
#   Example: ~/.zsh/completions/_all2md
#   Then add to .zshrc: fpath=(~/.zsh/completions $fpath)
#   And run: compinit

_all2md() {{
    local context state state_descr line
    typeset -A opt_args

    # Prioritize file completion - only show options when explicitly requested with --
    _arguments -s -S \\
{chr(10).join(option_specs)} \\
        '*:input file:_files'
}}

_all2md "$@"
"""

    return script


def generate_powershell_completion(catalog: dict[str, Any]) -> str:
    """Generate PowerShell completion script with embedded option data.

    Parameters
    ----------
    catalog : dict[str, Any]
        Serialized catalog data from _serialize_catalog_for_completion

    Returns
    -------
    str
        Complete PowerShell completion script

    """
    formats = catalog["formats"]

    # Build format-specific option lists
    parser_flags_by_format: dict[str, list[str]] = {}
    for fmt, options in catalog["parsers"].items():
        parser_flags_by_format[fmt] = [flag for opt in options for flag in opt["flags"]]

    renderer_flags_by_format: dict[str, list[str]] = {}
    for fmt, options in catalog["renderers"].items():
        renderer_flags_by_format[fmt] = [flag for opt in options for flag in opt["flags"]]

    # Build completion data with descriptions
    completions_with_desc: list[tuple[str, str]] = []
    for opt in catalog["global"]:
        help_text = opt.get("help", "")
        for flag in opt["flags"]:
            completions_with_desc.append((flag, help_text))

    # Generate PowerShell script
    script = """# PowerShell completion for all2md
# Generated by: all2md completion powershell
#
# Installation:
#   Add this line to your PowerShell profile ($PROFILE):
#   all2md completion powershell | Out-String | Invoke-Expression

Register-ArgumentCompleter -CommandName all2md -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $tokens = $commandAst.CommandElements
    $format = $null
    $outputType = $null

    # Extract format and output-type from command line
    for ($i = 0; $i -lt $tokens.Count; $i++) {
        $token = $tokens[$i].ToString()

        if ($token -eq '--format' -and ($i + 1) -lt $tokens.Count) {
            $format = $tokens[$i + 1].ToString()
        }
        elseif ($token -match '^--format=(.+)$') {
            $format = $Matches[1]
        }
        elseif ($token -eq '-f' -and ($i + 1) -lt $tokens.Count) {
            $format = $tokens[$i + 1].ToString()
        }
        elseif ($token -eq '--output-type' -and ($i + 1) -lt $tokens.Count) {
            $outputType = $tokens[$i + 1].ToString()
        }
        elseif ($token -match '^--output-type=(.+)$') {
            $outputType = $Matches[1]
        }
    }

    # Detect format from input file extension
    if (-not $format) {
        foreach ($token in $tokens) {
            $tokenStr = $token.ToString()
            if ($tokenStr -match '\\.([a-z0-9]+)$') {
                $format = $Matches[1]
                break
            }
        }
    }

    # Get previous token for context-aware completion
    $prevToken = if ($tokens.Count -gt 1) {{ $tokens[$tokens.Count - 2].ToString() }} else {{ '' }}

    # Complete format values
    if ($prevToken -eq '--format' -or $prevToken -eq '-f') {
        return @(
"""

    for fmt in formats:
        script += (
            f"            [System.Management.Automation.CompletionResult]::new("
            f"'{fmt}', '{fmt}', 'ParameterValue', '{fmt} format')\n"
        )

    script += """        )
    }

    # Complete output-type values
    if ($prevToken -eq '--output-type') {
        return @(
"""

    for fmt in formats:
        script += (
            f"            [System.Management.Automation.CompletionResult]::new("
            f"'{fmt}', '{fmt}', 'ParameterValue', '{fmt} format')\n"
        )

    script += """        )
    }

    # Build completion list based on context
    $completions = @(
"""

    # Add global flags
    for flag, desc in completions_with_desc:
        safe_desc = desc.replace("'", "''") if desc else flag
        script += (
            f"        [System.Management.Automation.CompletionResult]::new("
            f"'{flag}', '{flag}', 'ParameterName', '{safe_desc}')\n"
        )

    # Close the initial completions array
    script += "    )\n"

    # Add format-specific parser flags
    for fmt in sorted(parser_flags_by_format.keys()):
        script += f"""    if ($format -eq '{fmt}') {{
        $completions += @(
"""
        for flag in parser_flags_by_format[fmt]:
            script += (
                f"            [System.Management.Automation.CompletionResult]::new("
                f"'{flag}', '{flag}', 'ParameterName', '{fmt} parser option')\n"
            )
        script += "        )\n    }\n"

    # Add renderer-specific flags
    for fmt in sorted(renderer_flags_by_format.keys()):
        script += f"""    if ($outputType -eq '{fmt}') {{
        $completions += @(
"""
        for flag in renderer_flags_by_format[fmt]:
            script += (
                f"            [System.Management.Automation.CompletionResult]::new("
                f"'{flag}', '{flag}', 'ParameterName', '{fmt} renderer option')\n"
            )
        script += "        )\n    }\n"

    script += """
    # Show option completions when user has typed -- or -
    if ($wordToComplete -like '-*') {
        # If user typed exactly '--' or '-', show all flags
        if ($wordToComplete -eq '--' -or $wordToComplete -eq '-') {
            return $completions
        }
        # Otherwise filter completions that match the prefix
        $filtered = $completions | Where-Object { $_.CompletionText -like "$wordToComplete*" }
        if ($filtered) {
            return $filtered
        }
    }

    # Provide file/directory completions for non-flag arguments
    $paths = Get-ChildItem -Path "$wordToComplete*" -ErrorAction SilentlyContinue |
        ForEach-Object {
            $completionText = if ($_.PSIsContainer) { $_.Name + '\\' } else { $_.Name }
            [System.Management.Automation.CompletionResult]::new(
                $completionText,
                $_.Name,
                'ParameterValue',
                $_.FullName
            )
        }
    return $paths
}
"""

    return script


__all__ = ["handle_completion_command"]
