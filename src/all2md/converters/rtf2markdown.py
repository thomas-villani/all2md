#  Copyright (c) 2025 Tom Villani, Ph.D.
#
# src/all2md/converters/rtf2markdown.py

from __future__ import annotations

"""Rich Text Format (RTF) to Markdown conversion module.

This module provides functionality to convert Rich Text Format (RTF) documents
to Markdown, preserving essential formatting and structure. It uses the pyth
library for parsing RTF documents.

Key Features
------------
- Text formatting preservation (bold, italic, underline)
- Basic list detection (bulleted and numbered)
- Image extraction and handling via unified attachment processing
- Paragraph and line break management
- Smart quote conversion

Limitations
-----------
- **Tables**: RTF tables are not detected as structured tables and will appear
  as regular paragraphs. The pyth library does not provide table parsing.
- **Complex RTF files**: Files generated by Microsoft Word with extensive
  formatting may fail to parse due to pyth library limitations with modern RTF.
- **Hyperlinks**: Links are not preserved in the conversion.
- **Headers**: RTF heading styles are not detected; all text appears as paragraphs.
- **Advanced formatting**: Features like text colors, fonts, and advanced
  layouts are not preserved.

Dependencies
------------
- pyth: For parsing the RTF document structure

Note
----
For best results, use RTF files with simpler formatting. Complex RTF files
generated by modern word processors may encounter parsing errors.
"""

import io
import logging
import re
from pathlib import Path
from typing import IO, TYPE_CHECKING, Any, Optional, Union

from all2md.converter_metadata import ConverterMetadata
from all2md.exceptions import MarkdownConversionError
from all2md.options import MarkdownOptions, RtfOptions
from all2md.utils.attachments import create_attachment_sequencer, process_attachment
from all2md.utils.inputs import format_special_text, validate_and_convert_input
from all2md.utils.metadata import DocumentMetadata, prepend_metadata_if_enabled

# Type checking imports for static analysis without runtime overhead
if TYPE_CHECKING:
    from pyth.document import Document, Image, List, ListEntry, Paragraph, Text
    from pyth.plugins.rtf15.reader import Rtf15Reader

logger = logging.getLogger(__name__)


def extract_rtf_metadata(doc: Document) -> DocumentMetadata:
    """Extract metadata from RTF document.

    Parameters
    ----------
    doc : Document
        Parsed RTF document from pyth

    Returns
    -------
    DocumentMetadata
        Extracted metadata
    """
    # Import pyth types for isinstance checks
    from pyth.document import Document, Image, List, ListEntry, Paragraph, Text

    metadata = DocumentMetadata()

    # RTF documents parsed by pyth have limited metadata access
    # Most RTF metadata is not easily accessible through the pyth library
    # We can extract some basic document statistics and content analysis

    if not doc or not doc.content:
        return metadata

    # Count different element types
    paragraph_count = 0
    list_count = 0
    image_count = 0
    text_content = []

    def analyze_element(element: Any) -> None:
        nonlocal paragraph_count, list_count, image_count

        if isinstance(element, Paragraph):
            paragraph_count += 1
            # Extract text content for analysis
            for item in element.content or []:
                if isinstance(item, Text):
                    if isinstance(item.content, list):
                        text_content.extend(item.content)
                    else:
                        text_content.append(str(item.content))
                elif isinstance(item, Image):
                    image_count += 1
        elif isinstance(element, List):
            list_count += 1
            # Recursively analyze list content
            for entry in element.content or []:
                analyze_element(entry)
        elif isinstance(element, ListEntry):
            # Analyze list entry content
            for item in element.content or []:
                analyze_element(item)

    # Analyze all document content
    for element in doc.content:
        analyze_element(element)

    # Set document statistics
    if paragraph_count > 0:
        metadata.custom['paragraph_count'] = paragraph_count

    if list_count > 0:
        metadata.custom['list_count'] = list_count

    if image_count > 0:
        metadata.custom['image_count'] = image_count

    # Analyze text content
    if text_content:
        full_text = ' '.join(str(t) for t in text_content if t)

        # Word count
        words = full_text.split()
        if words:
            metadata.custom['word_count'] = len(words)

        # Character count
        if full_text.strip():
            metadata.custom['character_count'] = len(full_text.strip())

        # Try to extract title from first significant text
        # Look for title-like content (short first line or heading)
        text_lines = [line.strip() for line in full_text.split('\n') if line.strip()]
        if text_lines:
            first_line = text_lines[0]
            # If the first line is reasonably short and looks like a title
            if len(first_line) < 100 and not first_line.endswith('.'):
                # Check if it's likely a title (short, no sentence ending)
                words_in_first = first_line.split()
                if 1 <= len(words_in_first) <= 15:  # Reasonable title length
                    metadata.title = first_line

    # RTF document type
    metadata.custom['document_type'] = 'rtf'
    metadata.custom['format'] = 'Rich Text Format'

    return metadata


class RtfConverter:
    """A class to convert a pyth Document object to Markdown."""

    def __init__(self, options: RtfOptions, attachment_sequencer: Any = None):
        # Import pyth types for use in converter methods
        from pyth.document import Document, Image, List, ListEntry, Paragraph, Text

        self.options = options
        self.md_options = options.markdown_options or MarkdownOptions()
        self.attachment_sequencer = attachment_sequencer
        self.list_stack: list[tuple[str, int, int]] = []  # (type, level, number)
        self._base_filename: str = "document"  # Default base filename

        # Store type references as instance attributes for isinstance checks
        self.Paragraph = Paragraph
        self.List = List
        self.ListEntry = ListEntry
        self.Text = Text
        self.Image = Image
        self.Document = Document

    def convert(self, doc: Document) -> str:
        """Convert the pyth Document to a Markdown string."""
        if not doc:
            return ""

        markdown_parts = [self._process_element(elem) for elem in doc.content]

        # Clean up excessive newlines
        full_text = "".join(markdown_parts)
        return re.sub(r"\n{3,}", "\n\n", full_text).strip()

    def _process_element(self, element: Any) -> str:
        """Dispatch element processing to the appropriate method."""
        if isinstance(element, self.Paragraph):
            return self._process_paragraph(element)
        elif isinstance(element, self.List):
            return self._process_list(element)
        elif isinstance(element, self.ListEntry):
            return self._process_list_entry(element)

        # Other top-level elements can be added here
        return ""

    def _process_paragraph(self, para: Paragraph) -> str:
        """Convert a Paragraph object to Markdown."""
        if not para.content:
            return "\n"

        # Process inner content (mostly Text and Image objects)
        text_parts = []
        for item in para.content:
            if isinstance(item, self.Text):
                text_parts.append(self._process_text(item))
            elif isinstance(item, self.Image):
                text_parts.append(self._process_image(item))

        full_text = "".join(text_parts).strip()
        if not full_text:
            return "\n"

        # Heuristic for list detection
        indent = para.properties.get("start_indent", 0)
        # Assuming a standard indent of ~360 TWIPs per level
        level = int(indent / 360) + 1 if indent else 1

        list_type = None
        # Check for bullet/numbering prefixes
        # Be more specific about what constitutes a list item

        # Check for numbered lists (e.g., "1. ", "1) ", "1.\t")
        number_match = re.match(r"^(\d+)[.)]\s*\t?", full_text)
        if number_match:
            list_type = "number"
            full_text = full_text[number_match.end():].lstrip()
        # Check for bullet points with specific bullet characters followed by tab or space
        elif re.match(r"^[•·▪▫◦‣⁃]\t", full_text):
            list_type = "bullet"
            # Remove bullet and tab
            full_text = re.sub(r"^[•·▪▫◦‣⁃]\t", "", full_text).lstrip()
        # Check for dash/asterisk bullets (must have space after)
        elif re.match(r"^[-*]\s+", full_text):
            list_type = "bullet"
            full_text = re.sub(r"^[-*]\s+", "", full_text)
        # Check for indented items (tab at start indicates sub-item)
        elif full_text.startswith('\t') and len(full_text) > 1:
            # This is likely a sub-item
            list_type = "bullet"
            level = 2  # Indented item
            full_text = full_text.lstrip('\t')

        if list_type:
            # End deeper lists
            while self.list_stack and self.list_stack[-1][1] > level:
                self.list_stack.pop()

            if self.list_stack and self.list_stack[-1][1] == level:
                # Continue list at the same level
                current_number = self.list_stack[-1][2] + 1 if list_type == "number" else 1
                self.list_stack[-1] = (list_type, level, current_number)
            else:
                # Start a new list
                self.list_stack.append((list_type, level, 1))

            indent_str = " " * (self.md_options.list_indent_width * (level - 1))

            if list_type == "bullet":
                bullet = self.md_options.bullet_symbols[(level - 1) % len(self.md_options.bullet_symbols)]
                marker = f"{bullet} "
            else:  # number
                marker = f"{self.list_stack[-1][2]}. "

            return f"{indent_str}{marker}{full_text}\n"
        else:
            # Not a list, reset stack
            self.list_stack = []
            return f"{full_text}\n\n"

    def _process_list(self, list_elem: List) -> str:
        """Convert a List object to Markdown."""
        if not list_elem.content:
            return ""

        # Process each list entry
        list_parts = []
        for entry in list_elem.content:
            if isinstance(entry, self.ListEntry):
                list_parts.append(self._process_list_entry(entry))
            else:
                # Handle other potential content in lists
                list_parts.append(self._process_element(entry))

        return "".join(list_parts)

    def _process_list_entry(self, entry: ListEntry) -> str:
        """Convert a ListEntry object to Markdown."""
        if not entry.content:
            return "\n"

        # Process the content of the list entry
        entry_parts = []
        for item in entry.content:
            entry_parts.append(self._process_element(item))

        entry_text = "".join(entry_parts).strip()
        if not entry_text:
            return "\n"

        # Use bullet point format for list entries
        return f"- {entry_text}\n"

    def _process_text(self, text: Text) -> str:
        """Convert a Text object to Markdown, applying formatting."""
        # Text.content is a list of strings, so join them
        content = "".join(text.content) if isinstance(text.content, list) else str(text.content)
        if not content.strip():
            return content  # Preserve whitespace

        props = text.properties
        if props.get("bold"):
            content = f"**{content}**"
        if props.get("italic"):
            content = f"*{content}*"
        if props.get("underline"):
            # Use format_special_text to respect underline_mode setting
            underline_mode = self.md_options.underline_mode if self.md_options else "html"
            content = format_special_text(content, "underline", underline_mode)

        return content

    def _process_image(self, image: Image) -> str:
        """Process an Image object using the unified attachment handler."""
        image_data = image.data
        # Generate standardized image filename
        # Use sequencer if available, otherwise fall back to manual counting
        if self.attachment_sequencer:
            filename, _ = self.attachment_sequencer(
                base_stem=getattr(self, '_base_filename', 'document'),
                format_type="general",
                extension="png"
            )
        else:
            if not hasattr(self, '_img_counter'):
                self._img_counter = 0
            self._img_counter += 1

            from all2md.utils.attachments import generate_attachment_filename
            filename = generate_attachment_filename(
                base_stem=getattr(self, '_base_filename', 'document'),
                format_type="general",
                sequence_num=self._img_counter,
                extension="png"
            )
        alt_text = Path(filename).stem

        return process_attachment(
            attachment_data=image_data,
            attachment_name=filename,
            alt_text=alt_text,
            attachment_mode=self.options.attachment_mode,
            attachment_output_dir=self.options.attachment_output_dir,
            attachment_base_url=self.options.attachment_base_url,
            is_image=True,
            alt_text_mode=self.options.alt_text_mode,
        )


def rtf_to_markdown(
        input_data: Union[str, Path, IO[bytes]], options: Optional[RtfOptions] = None
) -> str:
    """Convert an RTF document to Markdown format.

    Processes RTF documents from various input sources and converts them to
    well-formatted Markdown, preserving structure and formatting like tables,
    lists, and text styles.

    Parameters
    ----------
    input_data : str, pathlib.Path, or file-like object
        RTF content to convert. Can be:
        - String path to an RTF file
        - pathlib.Path object pointing to an RTF file
        - File-like object (e.g., BytesIO) containing RTF data
    options : RtfOptions or None, default None
        Configuration options for RTF conversion. If None, uses default settings.

    Returns
    -------
    str
        Markdown representation of the RTF document.

    Raises
    ------
    InputError
        If input type is not supported or file cannot be read.
    MarkdownConversionError
        If the `pyth` library is not installed or if RTF parsing fails.
    """
    # Lazy import of heavy pyth dependencies
    try:
        from pyth.document import Document, Image, List, ListEntry, Paragraph, Text
        from pyth.plugins.rtf15.reader import Rtf15Reader
    except ImportError:
        Rtf15Reader = None

    if Rtf15Reader is None:
        raise MarkdownConversionError(
            "`pyth` library is required for RTF conversion. Install with: pip install pyth",
            conversion_stage="dependency_check",
        )

    if options is None:
        options = RtfOptions()

    try:
        doc_input, _ = validate_and_convert_input(
            input_data, supported_types=["path-like", "file-like"]
        )

        if isinstance(doc_input, (str, Path)):
            with open(doc_input, "rb") as f:
                doc = Rtf15Reader.read(f)
            base_filename = Path(doc_input).stem
        elif hasattr(doc_input, "read"):
            # Ensure we have a binary stream
            if isinstance(doc_input, io.TextIOBase):
                raise MarkdownConversionError("RTF input stream must be binary, not text.")
            doc = Rtf15Reader.read(doc_input)
            # Try to get filename from file object's name attribute
            if hasattr(doc_input, 'name') and doc_input.name not in (None, 'unknown'):
                base_filename = Path(doc_input.name).stem
            else:
                base_filename = "document"
        else:
            raise MarkdownConversionError(f"Unsupported input type for RTF conversion: {type(doc_input)}")

    except Exception as e:
        if isinstance(e, MarkdownConversionError):
            raise
        raise MarkdownConversionError(
            f"Failed to read or parse RTF document: {e}",
            conversion_stage="document_parsing",
            original_error=e,
        ) from e

    # Extract metadata if requested
    metadata = None
    if options.extract_metadata:
        metadata = extract_rtf_metadata(doc)

    # Extract base filename for standardized attachment naming
    if 'base_filename' not in locals():
        base_filename = "document"

    # Create attachment sequencer for consistent filename generation
    attachment_sequencer = create_attachment_sequencer()

    converter = RtfConverter(options, attachment_sequencer)
    converter._base_filename = base_filename  # Pass base filename to converter
    markdown_content = converter.convert(doc)

    # Prepend metadata if enabled
    result = prepend_metadata_if_enabled(markdown_content, metadata, options.extract_metadata)

    return result


# Converter metadata for registration
CONVERTER_METADATA = ConverterMetadata(
    format_name="rtf",
    extensions=[".rtf"],
    mime_types=["application/rtf", "text/rtf"],
    magic_bytes=[
        (b"{\\rtf", 0),
    ],
    converter_module="all2md.converters.rtf2markdown",
    converter_function="rtf_to_markdown",
    required_packages=[("pyth", "")],
    import_error_message="RTF conversion requires 'pyth'. Install with: pip install pyth",
    options_class="RtfOptions",
    description="Convert Rich Text Format documents to Markdown",
    priority=4
)
